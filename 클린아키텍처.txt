아키텍처란?
소프트웨어의 동작여부보다는 개발, 배포, 운영, 유지보수를 중심으로 소프트웨어 시스템을 구축하는 형태
개발 : 팀의 구조가 다르면 아키텍처 관련 결정에도 차이가 난다. 
(콘웨이 법칙 / 멜빈 콘웨이 : 시스템의 구조는 그 시스템을 설계하는 조직의 커뮤니케이션 구조와 동일하게 만든다.)
그러므로 커뮤니케이션의 구조가 단순해야한다.
(피자 두판의 법칙 / 아마존닷컴의 CEO인 제프 베조스 : 한 팀의 구성원은 피자 두 판으로 식사가 가능한 인원 수를 넘으면 안된다. 팀 구성원이 많을수록 커뮤니케이션 비용은 기하급수적으로 늘어난다.)
배포 : 배포 비용이 높을수록 시스템의 유용성은 떨어진다. 시스템을 한번에 배포할 수 있도록 하는 목표로 소프트웨어 아키텍처를 설계해야한다.
운영 : 개발, 배포, 유지보수보다 영향은 적다. 단순히 하드웨어의 추가 투입으로 해결이 가능한 경우가 대다수다. 바람직한 아키텍처는 개발자에게 운영 방식을 잘 드러내게 한다. 유스케이스, 기능, 시스템의 필수 행위를 1급엔티티로 격상시켜 주요 목표가 무엇인지 뚜렷하게 인식되게 해야한다.
유지보수 : 가장 비용이 많이드는 부분. 새로운 기능은 끝도없이 발생하고 뒤따르는 결함도 엄청난 인적자원이 소모된다. 시스템을 컴포넌트로 분리하고, 안정된 인터페이스를 두어 격리한다. (파사드 패턴)

소프트웨어 시스템은 두가지 구성요소로 분해
정책(Policy) 과 세부사항(Detail)
정책 요소는 업무 규칙(Business Rules)과 업무 절차(Procedures)를 구체화
세부사항은 입출력 장치, 데이터베이스, 웹, 프레임워크, 프로토콜 등
세부사항과 무관하게 고수준의 정책을 핵심으로 시스템을 구축해야 이를 기초로 신중한 선택사항을 결정할 수 있다. 세부사항에 우선순위를 두면 추후에 생길 많은 결정을 포기해야한다.


독립성
아키텍처의 지원 사항
- 시스템의 유스케이스
- 시스템의 운영
- 시스템의 개발
- 시스템의 배포
좋은 아키텍처는 결국 요구사항을 지원해야 한다. 이는 시스템의 유스케이스가 지원한다.
추가로 프로덕트의 라이프 사이클 중 유지보수를 제외한 운영, 개발, 배포 관점에서도 지원해야 한다.

업무 규칙은 어플리케이션에 밀접하거나, 혹은 더 범용적이거나
예를들어 유효성 검사는 어플리케이션에 밀접, 비즈니스 로직은 도메인에 밀접
이처럼 서로 다른 유형의 규칙은 변경되는 이유도, 속도도 다르다.
이들 규칙을 서로 분리하고, 독립적으로 변경할수있도록 만들어야 한다. 이것이 디커플링



경계: 선 긋기
소프트웨어 요소를 서로 분리하고, 경계 한편에 있는 요소가 반대편에 있는 요소를 알지 못하게 한다.
경계의 결정이 핵심적인 업무로직에 영향을 주지 않게 한다.
예
GUI는 업무규칙과 관련없으므로 선을 긋는다.
DB는 GUI와 업무규칙과 관련없으므로 선을 긋는다.
여기서 두 컴포넌트가 경계를 넘어 업무규칙으로 화살표로 그리면 업무규칙에서는 영향이 가지 않게 다양한 구현체로 선택할 수 있게 된다는 뜻이 된다. 이러한 세부사항에 관한 컴포넌트 추가와 관련된 패턴을 플러그인 아키텍처라 한다.

경계 해부학
모노리틱(Monolithic) 구조
소스 코드 의존성 관리를 위해 정적으로 링크된 C/C++ 프로젝트, jar파일, exe파일, NET바이너리 등을 실행하여 데이터를 전달하게 하는 방식을 채택하여 배포형 컴포넌트, 스레드, 로컬 프로세스, 서비스 등으로 컴포넌트를 분리하는 방법



정책과 수준
프로그램은 각 입력을 출력으로 변환하는 정책을 상세하게 기술한 설명서다.
하나의 정책은 여러 개의 조그만 정책들로 쪼갤 수 있다.
수준(Level)을 엄밀하게 정의하자면 '입력과 출력까지의 거리'다.
시스템의 입력과 출력 모두로 부터 멀리 위치할 수록 정책의 수준은 높아진다.
단일 책임 원칙(SRP)와 공통 폐쇄 원칙(CCP)에 따르면 동일한 이유로 동일한 시점에 변경되는 정책은 함께 묶인다. 고수준 정책, 즉 입력과 출력에서부터 멀리 떨어진 정책은 저수준 정책에 비해 덜 빈번하게 변경되고, 보다 중요한 이유로 변경되는 경향이 있다.
이처럼 모든 소스 코드 의존성의 방향이 고수준 정책을 향할 수 있도록 정책을 분리했다면 시스템의 최저 수준에서 중요하지 않지만 긴급한 변경이 발생하더라도, 보다 높은 위치의중요한 수준에 미치는영향은 거의 없게 된다.



업무 규칙(Business Rules)은 사업적으로 수익을 얻거나 비용을 줄일 수 있는 규칙 또는 절차다. 핵심 업무 규칙(Criticial Business Rule)은 컴퓨터 상으로 구현했는지와 상관없이, 업무 규칙은 사업적으로 수익을 얻거나 비용을 줄일 수 있어야 한다. 핵심 규칙과 핵심 데이터는 본질적으로 결합되어 있기 때문에 객체로 만들 좋은 후보가 된다. 우리는 이러한 유형의 객체를 엔티티(Entity)라고 부른다.
자동화된 시스템이 동작하는 방법을 정의하고 제약함으로써 수익을 더거나 비용을 줄이는 업무 규칙도 존재한다. 바로 이것이 유스케이스(Use case)다. 유스케이스는 애플리케이션에 특화된 업무 규칙(Application-specific Business Rules)을 설명한다.



소리치는 아키텍처
"핼스 케어 시스템이야" 또는 "재고 관리 스스템이야"라고 소리치는가? 아니면 사용하고 있는 디테일인 레일스(Rails)야", "스프링(Spring)/하이버네이트(Hibernate)야", 아니면 "ASP야"라고 소리치는가?
좋은 아키텍처는 유스케이스를 그 중심에 두기 때문에, 프레임워크나 도구 환경에 전혀 구애받지 않고 유스케이스를 지원하는 구조를 아무런 문제 없이 기술 할 수 있다.
좋은 소프트웨어 아키텍처는 프레임워크, 데이터베이스, 웹 서버, 그리고 여타 개발 환경 문제나 도구에 대해서는 결정을 미룰 수 있도록 만든다.



클린 아키텍처
소프트웨어를 계층으로 분리함으로써 이 관심사의 분리라는 목표를 달성한다. 이를 관심사의 분리(Seperation of concerns)라 한다.
이들 아키텍처는 모두 시스템이 다음과 같은 특징을 지니도록 만든다.
. 프레임워크 독립성
. 테스트 용이성
. UI 독립성
. 데이터베이스 독립성
. 모든 외부 에이전시에 대한 독립성