# WIL #2
## 항해99 부트캠프 ing

### 객체 지향 프로그래밍 (Object-Oriented Programming, OOP)


* 객체 지향 프로그래밍이란?

  객체 지향 프로그래밍은 컴퓨터 프로그래밍의 패러다임 중 하나이다. 객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 "객체"들의 모임으로 파악하고자 하는 것이다. 각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있다.
  객체 지향 프로그래밍은 프로그램을 유연하고 변경이 쉽게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다. 또한 프로그래밍을 더 배우기 쉽게 하고 소프트웨어 개발과 보수를 간편하게 하며, 보다 직관적인 코드 분석을 가능하게 하는 장점이 있다. 그러나 지나친 프로그램의 객체화 경향은 실제 세계의 모습을 그대로 반영하지 못한다는 비판을 받기도 한다.


* 기본 구성 요소

  1. 클래스(Class) - 같은 종류(또는 문제 해결을 위한)의 집단에 속하는 속성(attribute)과 행위(behavior)를 정의한 것으로 객체지향 프로그램의 기본적인 사용자 정의 데이터형(user defined data type)이라고 할 수 있다. 클래스는 다른 클래스 또는 외부 요소와 독립적으로 디자인하여야 한다. 프로그래머는 아니지만 해결해야 할 문제가 속하는 영역에 종사하는 사람이라면 클래스를 사용할 수 있다.

  2. 객체(Object) - 클래스의 인스턴스(실제로 메모리상에 할당된 것)이다. 객체는 자신 고유의 속성(attribute)을 가지며 클래스에서 정의한 행위(behavior)를 수행할 수 있다. 객체의 행위는 클래스에 정의된 행위에 대한 정의를 공유함으로써 메모리를 경제적으로 사용한다.
  
  3. 메서드(Method), 메시지(Message) - 클래스로부터 생성된 객체를 사용하는 방법으로서 객체에 명령을 내리는 메시지라 할 수 있다. 메서드는 한 객체의 서브루틴(subroutine) 형태로 객체의 속성을 조작하는 데 사용된다. 또 객체 간의 통신은 메시지를 통해 이루어진다.


* 하지만 Verify Signature는 SECRET KEY를 알지 못하면 복호화할 수 없다.

  A 사용자가 토큰을 조작하여 B 사용자의 데이터를 훔쳐보고 싶다고 가정해본다. 그래서 payload에 있던 A의 ID를 B의 ID로 바꿔서 다시 인코딩한 후 토큰을 서버로 보냈다. 그러면 서버는 처음에 암호화된 Verify Signature를 검사하게 된다. 여기서 Payload는 B사용자의 정보가 들어가 있으나 Verify Signature는 A의 Payload를 기반으로 암호화되었기 때문에 유효하지 않는 토큰으로 간주하게 된다. 여기서 A사용자는 SECRET KEY를 알지 못하는 이상 토큰을 조작할 수 없다는 걸 확인할 수 있다.


**특징**

  객체 지향 프로그래밍의 특징은 기본적으로 자료 추상화, 상속, 다형 개념, 동적 바인딩 등이 있으며 추가적으로 다중 상속 등의 특징이 존재한다. 객체 지향 프로그래밍은 자료 추상화를 기초로 하여 상속, 다형 개념, 동적 바인딩이 시스템의 복잡성을 제어하기 위해 서로 맞물려 기능하는 것이다.
  사람이 말로 표현 가능한 모든 것을 객체라 할 수 있다.

  1. 자료 추상화

    자료 추상화는 불필요한 정보는 숨기고 중요한 정보만을 표현함으로써 프로그램을 간단히 만드는 것이다. 자료 추상화를 통해 정의된 자료형을 추상 자료형이라고 한다. 추상 자료형은 자료형의 자료 표현과 자료형의 연산을 캡슐화한 것으로 접근 제어를 통해서 자료형의 정보를 은닉할 수 있다. 객체 지향 프로그래밍에서 일반적으로 추상 자료형을 클래스, 추상 자료형의 인스턴스를 객체, 추상 자료형에서 정의된 연산을 메소드(함수), 메소드의 호출을 생성자라고 한다.

  2. 상속

    상속은 새로운 클래스가 기존의 클래스의 자료와 연산을 이용할 수 있게 하는 기능이다. 상속을 받는 새로운 클래스를 부클래스, 파생 클래스, 하위 클래스, 자식 클래스라고 하며 새로운 클래스가 상속하는 기존의 클래스를 기반 클래스, 상위 클래스, 부모 클래스라고 한다. 상속을 통해서 기존의 클래스를 상속받은 하위 클래스를 이용해 프로그램의 요구에 맞추어 클래스를 수정할 수 있고 클래스 간의 종속 관계를 형성함으로써 객체를 조직화할 수 있다.

  3. 다중 상속

    다중 상속은 클래스가 2개 이상의 클래스로부터 상속받을 수 있게 하는 기능이다. 클래스들의 기능이 동시에 필요할 때 용이하나 클래스의 상속 관계에 혼란을 줄 수 있고(예: 다이아몬드 상속) 프로그래밍 언어에 따라 사용 가능 유무가 다르므로 주의해서 사용해야 한다. Java는 지원하지 않는다.

  4. 다형성 개념

    다형성 개념이란 어떤 한 요소에 여러 개념을 넣어 놓는 것으로 일반적으로 오버라이딩(같은 이름의 메소드가 여러 클래스에서 다른 기능을 하는 것)이나 오버로딩(같은 이름의 메소드가 인자의 개수나 자료형에 따라서 다른 기능을 하는 것)을 의미한다. 다형 개념을 통해서 프로그램 안의 객체 간의 관계를 조직적으로 나타낼 수 있다.

  5. 동적 바인딩

    동적 바인딩은 실행 시간 중에 일어나거나 실행 과정에서 변경될 수 있는 바인딩으로 컴파일 시간에 완료되어 변화하지 않는 정적 바인딩과 대비되는 개념이다. 동적 바인딩은 프로그램의 한 개체나 기호를 실행 과정에 여러 속성이나 연산에 바인딩함으로써 다형 개념을 실현한다.


* 장점

  소프트웨어 공학의 관점에서 볼 때 S/W의 질을 향상하기 위해 강한 응집력(Strong Cohesion)과 약한 결합력(Weak Coupling)을 지향해야 하는데, OOP의 경우 하나의 문제 해결을 위한 데이터를 클래스에 모아 놓은 데이터형을 사용함으로써 응집력을 강화하고, 클래스간에 독립적인 디자인을 함으로써 결합력을 약하게 한다.


* 객체 지향 언어

  다음은 대표적인 객체 지향 프로그래밍 언어들이다.
  * 시뮬라 67(영어: Simula 67): 최초의 객체 지향 언어로 알려져 있음
  * 스몰토크
  * 비주얼 베이직 닷넷
  * 오브젝티브-C
  * C++
  * C#
  * Dart
  * 자바
  * 객체지향 파스칼
  * 델파이
  * 파이썬
  * 펄
  * 루비
  * 액션스크립트
  * ASP
  * 스위프트


출처 : 위키피디아 [https://ko.wikipedia.org/wiki/%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D](https://ko.wikipedia.org/wiki/%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)




### 자바 가상 머신(Java Virtual Machine, JVM)


* 자바 가상 머신이란?

  자바 가상 머신은 자바 바이트코드를 실행할 수 있는 주체이다. 일반적으로 인터프리터나 JIT 컴파일 방식으로 다른 컴퓨터 위에서 바이트코드를 실행할 수 있도록 구현되나 jop 자바 프로세서처럼 하드웨어와 소프트웨어를 혼합해 구현하는 경우도 있다. (이론적으로는 100% 하드웨어 구현도 가능하나 비효율적이다) 자바 바이트코드는 플랫폼에 독립적이며 모든 자바 가상 머신은 자바 가상 머신 규격에 정의된 대로 자바 바이트코드를 실행한다. 따라서 표준 자바 API까지 동일한 동작을 하도록 구현한 상태에서는 이론적으로 모든 자바 프로그램은 CPU나 운영 체제의 종류와 무관하게 동일하게 동작할 것을 보장한다.


* 특성

  자바 가상 머신은 설계자인 제임스 고슬링(영어: James Gosling)에 따르면 UCSD 파스칼의 p-코드(영어: p-code)와 스몰토크 VM에 영향을 받았다고 한다. 자바 가상 머신은 이 두 가상 머신처럼 스택 기반이어서 대다수의 명령어가 스택 선두에서 피연산자를 택하고 결과는 다시 스택에 넣는다. 스택 상의 피연산자 타입을 구분하고 명령어에 스택 상의 피연산자 타입을 기술하는 면에서는 p-코드와 유사하며 실제 구조에는 차이가 있지만 가비지 컬렉션을 사용하고 객체와 메서드 호출 개념이 있다는 점에서는 스몰토크 가상 머신과 영향을 받았다고 볼 수 있다. 하지만 p-코드가 타입 안전성을 담보하지 못해 메모리 내용을 망가뜨릴 수 있다는 점, 그리고 스몰토크 가상 머신이 동적 타입을 사용하는 스몰토크 언어 자체와 마찬가지로 타입 구분을 하지 않는다는 점에서는 자바 가상 머신과 다르다.

  자바 가상 머신의 특성은 다음과 같다.

  * 스택 기반의 가상 머신
  * 단일 상속 형태의 객체 지향 프로그래밍을 가상 머신 수준에서 구현
  * 포인터를 지원하되 C와 같이 주소 값을 임의로 조작이 가능한 포인터 연산이 불가능
  * 가비지 컬렉션 사용
  * 모든 기본 타입의 정의를 명확히 함으로써 플랫폼 독립성 보장
  * 데이터 흐름 분석(영어: data flow analysis)에 기반한 자바 바이트코드 검증기(영어: verifier)를 통해 스택 넘침, 명령어 피연산자의 타입 규칙 위반, 필드 접근 규칙 위반, 지역 변수의 초기화 전 사용 등 많은 문제를 실행 전에 검증하여 실행 시 안전을 보장하고 별도의 부담을 줄여줌
  * 명령어에서 스택에서 가져올 피연산자의 타입을 명령어에 지정(예: 정수 덧셈은 iadd, 단정밀도 실수 덧셈은 fadd)


* 분류

  현재 사용되고 있는 자바 가상 머신 규격은 크게 네 가지로 나뉜다. 참고로 자바 플랫폼은 자바 SE, 자바 EE, 자바 ME, 자바 카드로 구분되나 자바 가상 머신 규격은 이 분류와 일치하지는 않는다. 자바 가상 머신 규격에 추가로 현재 자바 ME의 CLDC(Connected Limited Device Configuration)에서 하나 부분 집합, 자바 카드의 클래식 에디션(영어: classic edition), 커넥티드 에디션(영어: connected edition) 각기 하나 씩 부분 집합을 명시하고 있다.
  단, 규격이 동일하다고 해서 모두 같은 구현을 사용하지는 않는다. 일례로 자바 SE와 자바 EE, 자바 ME의 CDC(Connected Device Configuration)는 동일한 규격을 사용하고 있으나 함께 정의된 표준 API에서 차이가 있고 사용 환경 자체의 특성에 맞게 만들어진 별도의 구현이 존재한다. 오라클 구현의 경우 자바 SE를 위한 핫스팟 가상 머신은 사용 목적에 따라 최적화와 튜닝이 다른 서버용과 클라이언트용으로 나뉘며 서버용이 주로 자바 EE와 함께 많이 사용된다. 또 자바 ME CDC를 위해서도 적은 메모리와 낮은 CPU 사양에 맞춰진 CVM(C Virtual Machine)이라고 하는 별도 구현을 제공한다.


  1. 자바 SE

    * 모든 자바 플랫폼의 기본이 되는 플랫폼으로 자바 가상 머신, 자바 언어 규격 제정의 기준이 된다. 데스크톱 환경 및 서버 환경에서 공히 널리 사용된다.
    * 자바 가상 머신 규격에 따르는 VM 규격 사용
    * 주요 구현 : 오라클 HotSpot VM, 오라클 JRocket (추후 두 VM을 하나로 통합 예정)
  

  2. 자바 EE

    * 기업 서버 환경에서 사용될 목적으로 제정된 플랫폼으로 자바 SE에 추가 API가 더 정의된 형태이다.
    * 자바 가상 머신 규격에 따르는 VM 규격 사용
    * Java SE와 차이 없으며 HotSpot VM의 경우 서버용으로 튜닝된 버전이 있음


  3. 자바 ME

    * CLDC

      * 저사양 임베디드 시스템을 위한 플랫폼으로 특히 스마트폰이 아닌 피처폰에서 많이 사용된다. 8~32MHz 클럭으로 동작하는 16비트 혹은 32비트 프로세서, 최소 160KB ROM(Flash), 32KB RAM을 목표로한 플랫폼이다.

      * 규격

        다음과 같은 부분 집합
        * 사용자 정의 클래스 로더 제외
        * 스레드 그룹 및 데몬 스레드 제외
        * 객체 종결(finalization) 제외
        * 비동기 예외 제외
        * 리플렉션(reflection) 제외
        * 약한 레퍼런스(weak reference)를 제외한 레퍼런스 객체 제외
        * 실행 시 참조할 수 있는 애노테이션(annotation) 제외
        * Assertion 제외

      * 주요 구현 : 오라클 KVM, IBM WEME(WebSphere Everyplace Micro Environment) (: 동일한 코드에서 CLDC/CDC 버전을 도출)

    * CDC

      * 상대적으로 고사양 임베디드 시스템을 위한 플랫폼으로 디지털 TV나 블루레이 디스크 플레이어에 널리 사용되고 있다. 원래는 스마트폰 같은 고사양 휴대폰에도 CDC를 보급하는 것이 목적이었으나 안드로이드, iOS 위주로 재편된 시장에서는 거의 사용되지 않는다.

      * 규격 : 자바 SE와 동일하나 일부 핵심 API만 부분 집합

      * 주요 구현 : 오라클 CVM, IBM WEME, Myriad JBed


  4. 자바 카드

    * Classic Edition

      * 메모리/CPU가 제약된 스마트카드용 플랫폼으로 목표 환경은 통상 RAM 1.2KB, EEPROM이나 flash 16KB, ROM 32~48K 정도를 가진다.

      * 규격

        다음과 같은 부분 집합
        * 동적 클래스 로딩 제외
        * 보안 관리자(Security Manager) 제외
        * 객체 종결(finalization) 제외
        * 객체 복제(cloning) 제외
        * 자바 패키지 접근 권한 제어 일부 제한
        * 참조(reference) 객체 제외
        * 실행 시 참조할 수 있는 애노테이션(annotation) 제외
        * Assertion 제외
        * 클래스 파일 형식 대신 CAP (Converted Applet) 파일 사용
        * char, double, float, long 타입 제외

    * Connected Edition

      * 스마트카드의 고사양화에 의해 새로 추가된 플랫폼이다. 최소 환경은 비휘발성 메모리 176 KB, RAM 16KB를 요구한다. 통상적으로는 ROM 512KB, 읽고 쓸 수 있는 비휘발성 메모리 128KB, RAM 24KB 정도의 환경을 목표로 한다.

      * 규격

        다음과 같은 부분 집합
        * 부동소수점 타입 미지원
        * 사용자 정의 클래스 로드 제외
        * 스레드 그룹 및 데몬 스레드 제외
        * 객체 종결(finialization) 제외
        * 비동기 예외 제외
        * 리플렉션(reflection) 제외
        * 참조(reference) 객체 제외
        * 실행 시 참조할 수 있는 애노테이션(annotation) 제외
        * Assertion 제외


* 구현

  JVM은 자바 플랫폼의 주요한 부분이며 마이크로소프트 윈도우(95/98/NT), 리눅스, 유닉스, OS X 등 대부분의 운영 체제는 물론, 인터넷 익스플로러와 넷스케이프 등과 같은 웹 브라우저 등 여러가지 플랫폼에 설치되어 사용될 수 있으며, 휴대전화나 가전기기에도 설치할 수 있다. 따라서 자바 플랫폼은 여러 플랫폼을 지원하여 미들웨어로서의 역할과 플랫폼 스스로의 역할을 동시에 수행할 수 있다. 사용자는 자바 바이트코드로 컴파일된 자바 프로그램을 실행시키기 위해서 이 자바 가상 머신을 이용하면 된다.

  오라클(구 썬 마이크로시스템즈)에서 제공하는 자바 가상 머신 말고도 각 운영 체제 개발사가 제공하는 자바 가상 머신 및 오픈소스로 개발된 구형 버전의 온전한 자바 VM도 있으며, GNU의 GCJ나 아파치 소프트웨어 재단(ASF: Apache Software Foundation)의 하모니(Harmony)와 같은 아직은 완전하지 않지만 지속적인 오픈 소스 자바 가상 머신도 존재한다. 이러한 공개 소프트웨어 단체의 움직임에 따라 썬 마이크로시스템즈에서도 자사의 자바 가상 머신 및 개발 도구 킷을 오픈 소스 정책에 맞추어 공개한 상황이다.


출처 : 위키피디아 [https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94_%EA%B0%80%EC%83%81_%EB%A8%B8%EC%8B%A0](https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94_%EA%B0%80%EC%83%81_%EB%A8%B8%EC%8B%A0)

