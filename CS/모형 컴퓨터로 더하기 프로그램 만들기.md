# 모형 컴퓨터로 더하기 프로그램 만들기
## 항해99 부트캠프 ing


**모형 컴퓨터 설정**

  1. 실제 컴퓨터가 작동하는 방식을 설명하기 위한 상상 속 컴퓨터
  2. 명령어와 데이터를 저장하기 위한 메모리 존재
  3. 하나의 수를 담아낼(대입) 누산기 존재
  4. 연산 명령어 10개 존재
    * GET - 입력받은 수를 누산기에 대입
    * PRINT - 누산기 내용 출력
    * SOTRE M - 누산기의 내용을 메모리 M에 저장
    * LOAD M - 메모리 M의 내용을 누산기에 대입
    * ADD M - 메모리 M의 내용을 누산기에 더하여 대입
    * SPOP - 실행 중지
    * 나머지 명령어는 후술
  5. 프로세서의 작동 사이클
    * 인출(Fetch) : 메모리에서 다음 명령어를 가져온다.
    * 해석(Decode) : 명령어가 무슨일을 하는지 알아낸다.
    * 실행(Excute) : 명령어를 실행한 후 인출 단계로 돌아간다.


### 첫 번째 모형 프로그램

* 원하는 작업을 수행할 명령어를 작성 후 메모리에 저장하여 프로세서에 명령어를 실행하라고 지시

  예)
  ```txt
    GET
    PRINT
    STOP
  ```
  위와같은 단순한 프로그램을 만들고 사용자가 123라는 수를 입력했다면
  1. 사용자에게 수(123)를 입력받도록 요청하고 누산기에 대입한다.
  2. 누산기의 내용(123)을 출력한다.
  3. 프로세서를 중지한다.
  라는 과정의 프로그램으로 작동한다.


### 두 번째 모형 프로그램

* 두 수를 더하고, 그 합계를 출력하는 프로그램 만들기
  ```txt
    GET
    STORE FirstNum
    GET
    ADD FirstNum
    PRINT
    STOP
  FirstNum:
  ```
  위 프로그램의 작동 과정
  1. 사용자에게 수를 입력받도록 요청하고 누산기에 대입한다.
  2. 누산기의 내용을 FirstNum에 저장한다.
  3. 사용자에게 수를 입력받도록 요청하고 누산기에 대입한다. (덮어쓰기)
  4. 누산기의 내용에 FirstNum의 내용을 더하고 대입한다.
  5. 누산기의 내용을 출력한다.
  6. 프로세서를 중지한다.

* 이 프로그램의 까다로운 부분 1

  두번째 GET 명령어를 실행하면 첫번째 GET 명령어에서 누산기에 대입한 값을 덮어써 버리므로 첫번째 값을 미리 저장해 놓을 메모리를 확보해야 한다.

* 이 프로그램의 까다로운 부분 2

  프로그램 명령어가 메모리 위치를 필요로 할 때, 그 위치를 나타낼 방법이 필요하다.
  "첫번째 수" 라는 의미를 암시하기 위해 FirstNum이라는 이름을 붙여 위치를 나타내게 한다.

cf) 데이터 위치 이름 뒤에 콜론을 붙여 레이블임을 나타낸다. 관례상 명령어나 메모리 위치에 붙은 이름은 들여 쓰지 않는다.


### 분기 명령어

* 위 프로그램을 확장하여 세개의 수를 더하도록 하려면? STORE, GET, ADD 명령을 한번 더 추가하면 된다. 그러나...

* 1000개의 수를 더하도록 하려면? N개의 수를 더하도록 하려면?

  GOTO 명령어를 이용하자.
  GOTO X - X라는 위치로 이동하여 명령어를 처리한다.

  끝없이 실행되는 데이터 출력 프로그램 만들기
  ```txt
  Top:  GET           수를 입력받아 누산기에 대입한다.
        PRINT         누산기의 내용을 출력한다.
        GOTO Top      Top으로 이동한다.
  ```

* 조건부 분기(conditional branch) 또는 조건부 점프(conditional jump)를 사용하여 무한한 루프를 벗어난다.

  IFZERO X - 누산기의 내용이 0이면 X라는 위치로 이동하여 명령어를 처리한다.

  0이 입력되면 실행을 멈추는 데이터 출력 프로그램
  ```txt
  Top:  GET           수를 입력받아 누산기에 대입한다.
        IFZERO Bot    누산기의 내용이 0이면 Bot으로 이동한다.
        PRINT         누산기의 내용을 출력한다.
        GOTO Top      Top으로 이동한다.
  Bot:  STOP          프로세서를 중지한다.
  ```
  cf) 레퍼토리에 IFZERO가 있다면 이론상 어떠한 계산이든 수행 가능한 프로그램을 만들 수 있다. 여기서 '이론상으로'라고 표기한 이유는 실제로 프로세서 속도, 메모리 용량, 컴퓨터가 표현할 수 있는 수의 크기가 한정 되어있을 가능성을 무시할수 없기 때문.

* 위 프로그램은 0을 출력하지 않고 그냥 프로그램을 종료한다. 0을 출력시키려면?

  일련의 수를 합산하는 프로그램 만들기
  ```txt
  Top:  GET           수를 입력받아 누산기에 대입한다.
        IFZERO Bot    누산기의 내용이 0이면 Bot으로 이동한다.
        ADD Sum       누산기의 내용에 Sum의 내용을 더하고 대입한다.
        STORE Sum     누산기의 내용을 Sum에 저장한다.
        GOTO Top      Top으로 이동한다.
  Bot:  LOAD Sum      Sum의 내용을 누산기에 대입한다.
        PRINT         누산기의 내용을 출력한다.
        STOP          프로세서를 중지한다.
  Sum:  0             누적 합계를 담을 메모리 위치 (프로그램이 시작되면 0으로 초기화한다.)
  ```

* 위 프로그램 마지막 줄 Sum: 0 는 '메모리 위치에 이름을 할당하고 프로그램이 실행을 시작하기 전에 그 위치에 특정한 숫자 값을 넣어라' 라고 해석한다. 이는 실제 명령어가 아니라 시뮬레이터가 프로그램 실행을 시작하기 전에 프로그램 텍스트를 처리하는 과정에서 해석되는 '유사 명령어'에 가깝다.

* 잘 작동하는지 확인하려면?

  첫번째 테스트 : 0을 넣으면 0이 출력되어야 한다.
  두번째 테스트 : 1과 2를 넣으면 3이 되어야 한다.
  .
  .
  .
  발견하지 못한 문제점이 없도록, 핵심은 체계적으로 테스트 케이스를 선정하는것이 중요하다.


### 메모리 내부 표현

* 가정

  1. 각 명령어는 하나의 메모리를 사용
  2. 명령어가 메모리를 참조하거나 데이터 값을 사용하면 두개의 메모리 사용 (ex. IFZERO, ADD 등)
  3. 각 명령어 지정 숫자값
    GET = 1
    PRINT = 2
    STORE = 3
    LOAD = 4
    ADD = 5
    STOP = 6
    GOTO = 7
    IFZERO = 8

```txt
위치		메모리	레이블	명령어
1		1		Top:	GET
2		8				IFZERO Bot
3		10				
4		5				ADD Sum
5		14				
6		3				STORE Sum
7		14				
8		7				GOTO To
9		1				
10		4		Bot:	LOAD Sum
11		14				
12		2				PRINT
13		6				STOP
14		0		Sum:	0
```